//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// llvmc-based driver: auto-generated code
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

#include "llvm/CompilerDriver/BuiltinOptions.h"
#include "llvm/CompilerDriver/CompilationGraph.h"
#include "llvm/CompilerDriver/Error.h"
#include "llvm/CompilerDriver/Tool.h"

#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"

#include <algorithm>
#include <cstdlib>
#include <iterator>
#include <stdexcept>

using namespace llvm;
using namespace llvmc;

inline const char* checkCString(const char* s)
{ return s == NULL ? "" : s; }

namespace llvmc {
namespace autogenerated {

cl::opt<std::string> Parameter_stmsupport("stmsupport"
, cl::desc("path to stmsupport library"));

cl::opt<bool> Switch_m32("m32"
, cl::desc("force creation of 32bit code"));

cl::opt<bool> Switch_disable_dash_opt("disable-opt"
, cl::desc("disable all optimizations"));

cl::list<std::string> List_f("f"
, cl::Prefix, cl::desc("Additional compiler options"));

cl::opt<bool> Switch_g("g"
, cl::desc("enable debug information (disables optimizations)"));

cl::opt<std::string> Parameter_tangerpass("tangerpass"
, cl::init("tanger"), cl::desc("set transformation pass"));

cl::opt<bool> Switch_static("static"
, cl::desc("use static linking"));

cl::opt<std::string> Parameter_stmlib("stmlib"
, cl::desc("path to libtanger"));

cl::list<std::string> List_l("l"
, cl::Prefix, cl::desc("Add library when linking"));

cl::list<std::string> List_L("L"
, cl::Prefix, cl::desc("Search path for library"));

cl::opt<bool> Switch_n("n"
, cl::desc("link with native compiled stm instead of llvm compiled one"));

cl::opt<bool> Switch_force_dash_opt("force-opt"
, cl::desc("force an additional optimization"));

cl::list<std::string> SinkOption(cl::Sink);

} // End namespace autogenerated.
} // End namespace llvmc.

namespace hooks {
    std::string STMSUPPORTDIR();
    std::string STMLIBDIR();
} // End namespace hooks.

namespace {

using namespace llvmc::autogenerated;

class llvm_link_optimize : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_link_optimize";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_link_optimize is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "llvm-ld";
        vec.push_back(std::make_pair(0, "-link-as-library"));

        if (autogenerated::Switch_disable_dash_opt) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_link_optimize::InputLanguages_[] = {"llvm-bitcode", 0};

class llvm_link_together : public JoinTool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_link_together";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return true;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "llvm-ld";
        vec.push_back(std::make_pair(0, "-link-as-library"));

        if (autogenerated::Switch_disable_dash_opt) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }

        for (PathVector::const_iterator B = inFiles.begin(),
            E = inFiles.end(); B != E; ++B)
        {
            vec.push_back(std::make_pair(InputFilenames.getPosition(B - inFiles.begin()), B->str()));
        }
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(sys::Path(),
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "llvm-ld";
        vec.push_back(std::make_pair(0, "-link-as-library"));

        if (autogenerated::Switch_disable_dash_opt) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_link_together::InputLanguages_[] = {"llvm-bitcode", 0};

class llvm_tm_assembler : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_tm_assembler";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "executable";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_tm_assembler is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("out");

        cmd = "g++";
        vec.push_back(std::make_pair(0, hooks::STMLIBDIR() + std::string("/libtanger-stm.a")));
        vec.push_back(std::make_pair(0, "-pthread"));
        vec.push_back(std::make_pair(0, "-x"));
        vec.push_back(std::make_pair(0, "assembler"));

        if (autogenerated::Parameter_stmlib.empty()) {
            PrintError("-stmlib is not set");
            return 1;
        }
        if (!autogenerated::Parameter_stmlib.empty()) {
            vec.push_back(std::make_pair(65536, "-x"));
            vec.push_back(std::make_pair(65536, "none"));
        }
        if (autogenerated::Switch_g) {
            vec.push_back(std::make_pair(autogenerated::Switch_g.getPosition(), "-g"));
        }
        if (!autogenerated::List_l.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_l.begin(),
            E = autogenerated::List_l.end(); B != E;) {
                unsigned pos = autogenerated::List_l.getPosition(B - autogenerated::List_l.begin());
                vec.push_back(std::make_pair(pos, "-l" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_f.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_f.begin(),
            E = autogenerated::List_f.end(); B != E;) {
                unsigned pos = autogenerated::List_f.getPosition(B - autogenerated::List_f.begin());
                vec.push_back(std::make_pair(pos, "-f" + *B));
                ++B;
            }
        }
        if (!autogenerated::List_L.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::List_L.begin(),
            E = autogenerated::List_L.end(); B != E;) {
                unsigned pos = autogenerated::List_L.getPosition(B - autogenerated::List_L.begin());
                vec.push_back(std::make_pair(pos, "-L" + *B));
                ++B;
            }
        }
        if (autogenerated::Switch_static) {
            vec.push_back(std::make_pair(autogenerated::Switch_static.getPosition(), "-static"));
        }
        if (autogenerated::Switch_static) {
            vec.push_back(std::make_pair(65536, "-u"));
            vec.push_back(std::make_pair(65536, "pthread_create"));
        }
        if (autogenerated::Switch_m32) {
            vec.push_back(std::make_pair(autogenerated::Switch_m32.getPosition(), "-m32"));
        }
        if (autogenerated::Switch_n) {
            vec.push_back(std::make_pair(65536, hooks::STMLIBDIR() + std::string("/libtstm.a")));
        }
        if (! (autogenerated::Switch_n)) {
            vec.push_back(std::make_pair(65536, hooks::STMLIBDIR() + std::string("/libtanger-stm.a")));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        if (!autogenerated::SinkOption.empty()) {
            for (cl::list<std::string>::iterator B = autogenerated::SinkOption.begin(), E = autogenerated::SinkOption.end(); B != E; ++B)
                vec.push_back(std::make_pair(autogenerated::SinkOption.getPosition(B - autogenerated::SinkOption.begin()), *B));
        }
        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_tm_assembler::InputLanguages_[] = {"assembler", 0};

class llvm_tm_compiler : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_tm_compiler";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "assembler";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_tm_compiler is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("s");

        cmd = "llc";


        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_tm_compiler::InputLanguages_[] = {"llvm-bitcode", 0};

class llvm_tm_linker : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_tm_linker";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_tm_linker is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "opt";
        vec.push_back(std::make_pair(0, "will"));
        vec.push_back(std::make_pair(0, "be"));
        vec.push_back(std::make_pair(0, "replaced"));
        vec.push_back(std::make_pair(0, "with"));
        vec.push_back(std::make_pair(0, "builtin"));
        vec.push_back(std::make_pair(0, "pass"));
        vec.push_back(std::make_pair(0, "execution"));


        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_tm_linker::InputLanguages_[] = {"llvm-bitcode", 0};

class llvm_tm_stm_support : public Tool {
private:
    static const char* InputLanguages_[];

public:
    const char* Name() const {
        return "llvm_tm_stm_support";
    }

    const char** InputLanguages() const {
        return InputLanguages_;
    }

    const char* OutputLanguage() const {
        return "llvm-bitcode";
    }

    bool IsJoin() const {
        return false;
    }

    bool WorksOnEmpty() const {
        return false;
    }

    int GenerateAction(Action& Out,
        const PathVector& inFiles,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        PrintError("llvm_tm_stm_support is not a Join tool!");
        return -1;
    }

    int GenerateAction(Action& Out,
        const sys::Path& inFile,
        const bool HasChildren,
        const llvm::sys::Path& TempDir,
        const InputLanguagesSet& InLangs,
        const LanguageMap& LangMap) const
    {
        std::string cmd;
        std::string out_file;
        std::vector<std::pair<unsigned, std::string> > vec;
        bool stop_compilation = !HasChildren;
        bool no_out_file = false;
        std::string output_suffix("bc");

        cmd = "llvm-ld";
        vec.push_back(std::make_pair(0, "-link-as-library"));
        vec.push_back(std::make_pair(0, hooks::STMSUPPORTDIR() + std::string("/stmsupport.bc")));

        if (autogenerated::Parameter_stmlib.empty()) {
            PrintError("-stmlib is not set");
            return 1;
        }
        if (autogenerated::Parameter_stmsupport.empty()) {
            PrintError("-stmsupport is not set");
            return 1;
        }
        if (autogenerated::Switch_disable_dash_opt) {
            vec.push_back(std::make_pair(65536, "-disable-opt"));
        }
        if (! (autogenerated::Switch_n)) {
            vec.push_back(std::make_pair(65536, hooks::STMLIBDIR() + std::string("/libtanger-stm.bc")));
            vec.push_back(std::make_pair(65536, "-internalize-public-api-file"));
            vec.push_back(std::make_pair(65536, hooks::STMLIBDIR() + std::string("/libtanger-stm.public-symbols")));
        }

        vec.push_back(std::make_pair(InputFilenames.getPosition(0), inFile.str()));
        if (!no_out_file) {
            vec.push_back(std::make_pair(65536, "-o"));
            out_file = this->OutFilename(inFile,
                TempDir, stop_compilation, output_suffix.c_str()).str();

            vec.push_back(std::make_pair(65536, out_file));
        }

        Out.Construct(cmd, this->SortArgs(vec), stop_compilation, out_file);
        return 0;
    }

};
const char* llvm_tm_stm_support::InputLanguages_[] = {"llvm-bitcode", 0};

class Edge1: public Edge {
public:
    Edge1() : Edge("llvm_link_optimize") {}

    int Weight(const InputLanguagesSet& InLangs) const {
        unsigned ret = 0;
        if (autogenerated::Switch_force_dash_opt) {
            ret += 2;
        }
        return ret;
    }

};

} // End anonymous namespace.

namespace llvmc {
namespace autogenerated {

int PreprocessOptions () {

    return 0;
}

int PopulateLanguageMap (LanguageMap& langMap) {
    langMap["bc"] = "llvm-bitcode";
    langMap["o"] = "llvm-bitcode";
    langMap["ll"] = "llvm-ir";

    return 0;
}

int PopulateCompilationGraph (CompilationGraph& G) {
    G.insertNode(new llvm_link_optimize());
    G.insertNode(new llvm_link_together());
    G.insertNode(new llvm_tm_assembler());
    G.insertNode(new llvm_tm_compiler());
    G.insertNode(new llvm_tm_linker());
    G.insertNode(new llvm_tm_stm_support());

    if (int ret = G.insertEdge("root", new SimpleEdge("llvm_link_together")))
        return ret;
    if (int ret = G.insertEdge("llvm_link_together", new Edge1()))
        return ret;
    if (int ret = G.insertEdge("llvm_link_together", new SimpleEdge("llvm_tm_linker")))
        return ret;
    if (int ret = G.insertEdge("llvm_link_optimize", new SimpleEdge("llvm_tm_linker")))
        return ret;
    if (int ret = G.insertEdge("llvm_tm_linker", new SimpleEdge("llvm_tm_stm_support")))
        return ret;
    if (int ret = G.insertEdge("llvm_tm_stm_support", new SimpleEdge("llvm_tm_compiler")))
        return ret;
    if (int ret = G.insertEdge("llvm_tm_compiler", new SimpleEdge("llvm_tm_assembler")))
        return ret;

    return 0;
}

} // End namespace autogenerated.
} // End namespace llvmc.

